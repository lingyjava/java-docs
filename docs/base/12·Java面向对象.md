# 12·面向对象

- [12·面向对象](#12面向对象)
  - [什么是面向对象](#什么是面向对象)
  - [属性](#属性)
  - [封装](#封装)
  - [继承](#继承)
  - [多态](#多态)
  - [静态](#静态)
  - [抽象类](#抽象类)
  - [接口](#接口)

## 什么是面向对象
面向对象编程(Object-Oriented Programming , OOP)：以类的方式组织代码，以对象的组织(封装)数据。
将实现功能的方法封装的类中，在使用时调用。
对象：类的具体实例。
类：一类事物共同特征的抽象描述。
[面向对象与面向过程编程的区别和优缺点](https://www.cnblogs.com/strivers/p/6681876.html)

## 属性
全局属性：直接定义在类中的属性。

局部属性：定义在方法内的属性。
区别：

1.  全局属性在使用前如果不赋值,系统会赋默认值,局部属性在使用前必须赋值。 
2.  局部变量的名字可以和全局变量一致,但是使用时默认使用局部变量,不建议名字一致。 
3.  全局变量的作用域是整个类,局部变量作用域在方法内。 

参数：方法在执行之前需要动态的给定一些数据,那么这些数据就通过参数的方式传递到方法内部。

1.  在调用该方法时传递的参数类型以及顺序必须和定义时一致。 
2.  如果方法有返回值在定义方法的必须把void替换成对应类型返回值,方法执行完后必须在最后使用return返回对应类型的结果。 

## 封装
所有属性必须私有化，根据需求提供get/set方法对其访问。

方法：把相同的功能代码集中写在方法中，方法一般是public

## 继承
继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。

在程序设计中可以通过继承来删减同一类事物的相同代码。降低类之间的耦合。

1. 子类继承父类非私有属性和方法。
2. 子类无法继承父类的构造方法。但是子类在创建对象之前必先创建父类对象(在子类的构造方法中会默认调用父类的无参构造方法)。
3. Java只能单继承,一个类只能有一个直接父类。
4. 如果子类重写了父类中的方法,不管怎么调用全部执行的是子类重写后的方法。
5. 在Java中(除了8种基本数据类型),所有的类全部直接或间接的继承Object方法。
6. 子类在创建对象时先加载父类再加载子类。

super：在子类中代表父类对象，可以通过super调用父类的方法和属性。

1. 在子类的构造方法中调用父类的构造方法,必须写在第一行。
2. private 只能被本类访问，super也无法访问。
3. super和this不能同时调用构造方法。
4. 在子类的方法中通过super调用父类的属性以及方法。先执行父类的静态方法-->子类的静态方法-->父类的非静态方法-->子类的非静态方法

this：在构造方法中区分局部变量和全局变量。表示本类对象，在方法中调用另一个方法。

instanceof：判断有无父子关系

## 多态
一个对象的多种形态，同一方法可以根据发送对象的不同而采用多种不同的行为方式。

多态可以实现不改变原有的代码，增加新的功能。

程序中定义的引用变量指向的具体类型和发出的方法调用在编程时不确定，在程序运行时才确定。

一个引用变量指向哪个实例对象，调用哪个类的方法，在程序运行时才确定具体的类。

让一个引用变量绑定在不同的实现上，不用修改源码可以改变程序运行时的具体实现代码，让程序可以选择多个运行状态，这就是多态性。

1. 多态建立在继承关系上。
2. 如果子类重写了父类中的方法，父类的引用在调用该方法时是子类重写后的方法。(多态实现原理)
3. 父类的引用只能调用子类和父类共有的方法(也就是父类中的方法)，不能调用子类独有的方法。
4. 子类类型可以自动转换为父类类型，但是父类类型需要强制类型转换为子类。
5. 优点：清除类型之间的耦合关系，可扩充性，接口性，灵活性，简化性。
```java
public static void main(String[] args) {
    	/*创建Feeder对象*/
        Feeder feeder = new Feeder();
        Cat cat = new Cat();
        Dog dog = new Dog();
    	/*feed方法的参数为animal是cat和dog的父类，cat和dog类重写了feed方法，所以这里可以根据对象不同调用不同的方法*/
        feeder.feed(cat);
        feeder.feed(dog);

    }
	//instanceof:判断当前对象是否是该类的一个实例，如果是返回true。
	if(animal instanceof Cat){
	    Cat cat = new Cat();
	    cat.eat();
	}
	if(animal instanceof Dog){
	    Dog dog = new Dog();
	    dog.eat();
	}
```

## 静态
使用static修饰的属性和方法是类成员，类成员是属于类的。

1. 静态区和程序一起加载。
2. 静态变量可以用类名.访问。
3. 静态方法直接调用。

实例成员:普通的属性和方法(非static修饰)，实例成员必须要使用对象调用。

1.  使用static修饰的属性是所有该类实例共享的属性。一般使用类名调用。 
2.  静态(类成员)在类加载时就已经执行了，此时对象还没有创建。 
3.  静态成员无论对象创建多少个只会执行一次。因为类只加载一次。 
4.  在静态方法中无法调用普通方法，也无法使用this和super关键字。 

静态代码块：static{}：用来给静态变量赋初始值。
静态代码块随着类一起加载。

final:常量，使用final修饰的变量是常量，常量在创建时必须要赋值，定义后不可改变，常量名全部大写。

Object:所有类的直接或间接父类。
Object下的方法：
hashCode():返回对象的哈希码值
finalize():当垃圾回收确定不再有对象的引用时，垃圾收集器在对象上调用该对象
toString():返回对象的字符串表示形式
equals():指示一些其他对象是否等于此

## 抽象类
使用abstract修饰，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就可以设计为抽象类。

类中有抽象方法，类必须是抽象类。抽象类不一定有抽象方法，有抽象方法一定是抽象类。

抽象类不能创建对象，唯一的作用是为了让子类继承，并且必须实现父类的抽象方法。

抽象方法没有方法体(甚至没有大括号)，当父类中的方法必须让子类重写，那么可以定义为抽象方法，该类也就定义为抽象类。

## 接口
接口:一系列方法的声明，是一些方法特征的集合，需要重写实现接口中的方法。使用interface修饰。项目经理给出的程序设计的约定和规则。

1. 属性全部是常量，方法全部是抽象方法，不能有普通方法，子类必须重写接口中的所有方法。
2. 接口不能用来创建对象。
3. 类通过implement实现接口，可以多实现。
4. 一个类可以继承一个类，同时还可以实现多个接口，继承写在继承后。
5. 一个接口可以继承多个接口。
