# 2·Java 语言元素

- [2·Java 语言元素](#2java-语言元素)
  - [关键字](#关键字)
  - [注释](#注释)
  - [字符 字节 位 编码](#字符-字节-位-编码)
  - [基本数据类型](#基本数据类型)
    - [整型](#整型)
    - [浮点型](#浮点型)
    - [字符类型](#字符类型)
    - [布尔类型](#布尔类型)
    - [Unicode](#unicode)
    - [存储空间疑问](#存储空间疑问)
    - [类型转换](#类型转换)
    - [进制标记](#进制标记)
  - [包装类](#包装类)
    - [装拆箱](#装拆箱)
    - [常量池](#常量池)
  - [变量 常量](#变量-常量)
  - [运算符](#运算符)
    - [算数运算](#算数运算)
    - [关系运算](#关系运算)
    - [逻辑运算](#逻辑运算)
    - [位运算](#位运算)
    - [自增自减](#自增自减)
    - [三元运算符](#三元运算符)
  - [流程控制](#流程控制)
    - [选择结构](#选择结构)
      - [if else](#if-else)
      - [switch case](#switch-case)
    - [循环结构](#循环结构)
      - [for](#for)
      - [while](#while)
      - [迭代器](#迭代器)
      - [增强for](#增强for)
    - [break continue](#break-continue)
  - [类与对象](#类与对象)
  - [方法](#方法)
    - [构造方法](#构造方法)
    - [访问修饰符](#访问修饰符)
    - [定义](#定义)
    - [调用](#调用)
    - [重写](#重写)
    - [重载](#重载)
    - [可变参数](#可变参数)
    - [递归](#递归)
  - [枚举](#枚举)
  - [内部类](#内部类)
    - [成员内部类](#成员内部类)
    - [静态内部类](#静态内部类)
    - [局部内部类](#局部内部类)
    - [匿名内部类](#匿名内部类)
    - [内部类常见问题](#内部类常见问题)
  - [包管理](#包管理)
  - [值传递 引用传递](#值传递-引用传递)
  - [编码规范](#编码规范)
  - [脚注](#脚注)


## 关键字

Java中有51个关键字和2个保留字，关键字不能用于命名（变量、对象）。

| **保留字**                                 |                                                              |
| ------------------------------------------ | ------------------------------------------------------------ |
| goto                                       | 不允许使用                                                   |
| const                                      | 不允许使用                                                   |
| **访问修饰符**                             |                                                              |
| public                                     | 公共的，在任何地方可引用                                     |
| private                                    | 私有的，在本类中可引用                                       |
| protected                                  | 受保护的，在本包或子类中可引用                               |
| default                                    | 默认的，在本包中可引用                                       |
| **定义类、接口、抽象类、实现、继承、枚举** |                                                              |
| class                                      | 定义一个类                                                   |
| interface                                  | 定义一个接口                                                 |
| abstract                                   | 修饰类为抽象类                                               |
| implement                                  | 声明类实现的接口                                             |
| extends                                    | 声明类继承的类                                               |
| enum                                       | 定义一个枚举类                                               |
| new                                        | 创建一个对象                                                 |
| super                                      | 调用父类方法、变量                                           |
| this                                       | 调用本类方法、变量                                           |
| **包**                                     |                                                              |
| package                                    | 声明包路径                                                   |
| import                                     | 引入包                                                       |
| **数据类型**                               |                                                              |
| byte                                       | 字节型，8bit                                                 |
| char                                       | 字符型，16bit                                                |
| boolean                                    | 布尔类型                                                     |
| short                                      | 短整型，16bit                                                |
| int                                        | 整型，32bit                                                  |
| float                                      | 浮点型，32bit                                                |
| long                                       | 长整型，64bit                                                |
| double                                     | 双精度浮点型，64bit                                          |
| void                                       | 修饰方法无返回值                                             |
| null                                       | 对象没有值则为null                                           |
| true                                       | 真                                                           |
| false                                      | 假                                                           |
| **流程控制**                               |                                                              |
| if、else                                   | 选择结构                                                     |
| switch、case                               | 选择结构                                                     |
| do、while                                  | 循环结构                                                     |
| for                                        | 循环结构                                                     |
| continue                                   | 结束本次循环，开始下次循环                                   |
| break                                      | 跳出循环                                                     |
| return                                     | 结束当前方法并返回                                           |
| **运算符**                                 |                                                              |
| instanceof                                 | 判断左边的对象是否是右边对象的实例，返回布尔类型             |
| **静态、本地、最终**                       |                                                              |
| static                                     | 修饰类、方法、变量为静态。单独使用为静态区                   |
| final                                      | 修饰类、方法、变量为最终的。类不可被继承、方法不可被重写、变量不可变（常量） |
| native                                     | 修饰方法为本地方法                                           |
| **线程**                                   |                                                              |
| synchronized                               | 修饰方法，线程同步，使线程在某个方法中同步执行               |
| volatile                                   | 修饰变量、方法，线程同步，可以保证有序性。                   |
| **异常**                                   |                                                              |
| try                                        | 尝试在try块中的异常捕捉                                      |
| catch                                      | 处理异常                                                     |
| finally                                    | 异常处理块中的最终执行，始终会被执行                         |
| throw                                      | 不处理异常，向上抛出异常                                     |
| throws                                     | 声明方法可能抛出的异常                                       |
| assert                                     | 断言                                                         |
| **其他**                                   |                                                              |
| transient                                  | 修饰变量，在实现Serilizable接口，不被序列化                  |
| strictfp                                   | 修饰类、接口、方法。关键字声明范围内所有浮点运算都是精确的，符合IEEE-754规范的。 |

## 注释

代码注释是程序代码可维护性的重要环节之一。 编译器会忽略这些代码，不会出现在可执行程序中。



使用方式：

三种注释方式：单行注释、多行注释、文档注释。

其中文档注释中可以加入特殊标记说明，用于标识代码中的特殊引用。标记由`@标记类型 专用注释引用`  组成。

| 标记       | 简述                             |
| ---------- | -------------------------------- |
| @author    | 标记类，表示作者名               |
| @version   | 标记类、方法，表示版本号         |
| @param     | 标记方法，表示方法入参           |
| @return    | 标记方法，表示方法返回值         |
| @exception | 标记方法，表示方法可能抛出的异常 |
| @see       | 标记类、方法，表示参考转向       |
| TODO       | 特殊标记, 备注此处未完成         |
| XXX        | 特殊标记, 此处代码有待商榷、改进 |
| FIXME      | 特殊标记, 此处代码待修复         |

```java
/**
 * 这是文档注释, 描述这个方法的一切.
 * @author lingy
 * @version 1.0
 * @param 无参数
 * @return 无返回值
 * @exception 可能抛出的异常
 * @see 参考的对象
 * */
public void test() {
    
    // 这是单行注释, 描述变量意义、逻辑
    
    /*
    * 这是多行注释
    * 描述一段代码、逻辑、或者备注
    * */

    // TODO 特殊标记, 备注此处未完成
    // XXX 特殊标记, 此处代码有待商榷、改进
    // FIXME 特殊标记, 此处代码待修复
}
```



使用规则：

- 必须加的基本注释：**类，接口，构造函数，方法，全局变量，属性。**
- 必须加的特殊注释：**算法，代码不明晰，代码修改处，循环与选择分支嵌套，向外提供的接口。**
- 使用统一的标点。
- 内容简单明了、含义准确、内容不大于10个字。
- `get/set`方法不需加注释。

## 字符 字节 位 编码

位（bit）：数据存储最小单位，存储一个二进制位 0 或 1。

字节（byte）：1byte = 8bit，1KB = 1024 B（字节），1MB = 1024KB，1GB = 1024MB，以此类推。

字符：a、A、汉、+、-、$…均表示一个字符，在不同编码下，汉字字符占用字节不同，UTF8（3个字节），GBK（2个字节）。

字符集：收录标准的各个字符的集合。

编码： 规定字符存储规定，实际是对字符集中的字符进行编码，用二进制格式存储，展示时再用对应的编码解析（解码），常见的编码规则：gbk、Unicode、ASCii…

## 基本数据类型

Java中有8大基本数据类型（整型、浮点型、字符型、布尔型）。

### 整型

Java提供4种整型，用于表示没有小数部分的数值，可以是负数。

存储范围：2 ^M-1^ ，M为存储空间位数，首位为符号位，故 - 1.

| 类型  | 大小（字节） | 取值范围           |
| ----- | ------------ | ------------------ |
| long  | 8            | -2^63^ ~ 2^63^ - 1 |
| int   | 4            | -2^31^ ~ 2^31^ - 1 |
| short | 2            | -2^15^ ~ 2^15^ - 1 |
| byte  | 1            | -2^7^ ~ 2^7^ - 1   |

### 浮点型

Java提供了2种浮点类型，用于表示有小数部分的数值。

存储范围：M * 2^E^，M是尾数，E是指数。指数E中一位为符号位，一位用于指数的偏移量。故有效数字为E - 1 或E - 2.

| 类型   | 大小（字节） | 取值范围                                         |
| ------ | ------------ | ------------------------------------------------ |
| double | 8            | M占46位，E占17位，符号位1位（有效位数为15~16位） |
| float  | 4            | M占23位，E占8位，符号位1位（有效位数为6~7位）    |

浮点数计算问题：

- 由于浮点数是近似表示的，因此在进行浮点数运算时，可能会出现舍入误差。
- float类型的数值需有后缀F或者f，没有后缀F的浮点数值默认转换为double类型。
- double类型的数值需有后缀D或者d，可以省略。
- 所有的浮点数值计算都遵循IEEE754规范。**浮点类型应避免进行比较。** 表示溢出和出错情况的特殊的浮点数值：正无穷大（一个正整数除以0）、负无穷大、NaN（计算0/0或者负数的平方根）。
- 浮点数值不适用于无法接受舍入误差的金融计算（如2.0-1.1=0.8999999999999999）。如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类。 这种误差是由于浮点数值采用二进制表示，二进制种无法精准地表示分数1/10，就好像十进制中无法精准地表示分数1/3一样。

### 字符类型

字符类型 char，原本用于表示单个字符。而Unicode 字符编码需要用一个或两个 char 值描述。char 类型的值可以表示为十六进制值，范围从\u0000~\uFFFF \u2122表示商标符号（TM） \u03C0表示希腊字母（Π）

char 类型的字面值使用单引号包括（如 'A' 是编码值为 65 的字符常量，这与 "A" 不同，"A"是包含一个字符 A 的字符串）。

| 转移序列 | 名称   | Unicode值 |
| -------- | ------ | --------- |
| \b       | 退格   | \u0008    |
| \t       | 制表   | \u0009    |
| \n       | 换行   | \u000a    |
| \r       | 回车   | \u000b    |
| \"       | 双引号 | \u0022    |
| \'       | 单引号 | \u0027    |
| \\       | 反斜杠 | \u005c    |

### 布尔类型

布尔类型 boolean 仅有两个常量值：true、false，用来表示逻辑真 或 假。

### Unicode

Unicode 编码规则打破了传统字符编码机制的限制。在Unicode出现前，有许多不同的标准（美国的ASCII，西欧的ISO8859-1，俄罗斯的KOI-8，中国的GB-18030和BIG-5等），这导致在不同的编码方案下可能对应不同的字母。

Unicode 启动了统一工作。 在 Java中，char 类型描述了 UTF-16 编码中的一个代码单元。**强烈建议不要在程序中使用 char 类型**，除非确实需要处理UTF-16代码单元，最好将字符串作为抽象数据类型处理。

###  存储空间疑问

**为何存储空间少一位，long为8byte，64bit，取值范围却只到63次方？**

Java中存储数值时第一位是符号位，用于区分正负数，所以存储空间少一位。

---

**为何正数取值范围需要-1？**

因为负数的取值是由正数取反加1的规则，既取补码得到，目的是为了正负数在计算时可以使用同一套逻辑。

以`short`类型举例：其最大值是`0111 1111 1111 1111 ` = 2^15^ - 1，其最小值就是`1000 0000 0000 0000` ，取反码加1（补码）后是`1000 0000 0000 0000`，其值本应当为0，但数值0已经由`0000 0000 0000 0000`表示，故将`1000 0000 0000 0000`的数值定义为-2^15^，故正数比负数少一个取值。

### 类型转换

类型转换指将一种数据类型转换为另一种数据类型。 低精度到高精度数据类型自动转换。 高精度到低精度需要强制转换，丢失部分精度。语法：`【类型】 【变量名】` 数据类型的精度从低到高为：byte，short，char，int，long，float，double，**布尔类型不能进行转换。**

![基本数据类型转换](https://github.com/lingyjava/image-hosting-service/blob/main/java/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.jpeg)

特殊规则：

- 当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后进行计算。
- 将浮点数转换为整型时，精度丢失方式是通过截断小数的部分。
- 类型转换时，如果超出了目标类型的表示范围，结果就会截断成一个完全不同的值。 `(byte) 300` 实际值为 44.

### 进制标记

从 JDK7 开始，可以加上前缀标记不同的进制。 

`0b`或`0B`标记二进制数（如0b1001对应十进制中的9） 

`0x`或`0X`标记十六进制数（如0xCAFE） 

`0`标记八进制数（如010对应十进制中的8），**八进制显然很容易混淆，尽量不要使用八进制常数。**

## 包装类

包装类是基于8大基本数据类型的封装，值允许为NULL且默认为NULL，并提供了实用API。

包装类属于对象类型，对象的值之间进行比较必须使用 `equals` 方法。

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| long         | Long      |
| int          | Integer   |
| short        | Short     |
| byte         | Byte      |
| double       | Double    |
| float        | Float     |
| boolean      | Boolean   |
| char         | Character |

### 装拆箱

装拆箱是指基本数据类型与对应的包装类型互相转换的过程，装拆箱可以自动进行，应避免非必要的装拆箱，否则将影响系统性能。

装箱：将基本数据类型转换为对应的包装类型。

拆箱：将包装类型转换为对应的基本数据类型。

```
Integer i = 40; // 装箱 等价于 Integer i = Integer.valueOf(40);
int j = i; // 拆箱 等价于 int j = i.intValue();
```

### 常量池

大部分包装类默认创建了部分常用数值，使用以下范围的数值将直接指向常量值中的数值：

- 整型包装类缓存值（-127 ~ 128）。
- `Character`缓存值（0 ~ 127）。
- `Boolean`缓存值（True 、False）。
- 浮点型包装类没有使用常量池技术。

需注意当使用常量池缓存时，值相等的两个对象使用 `==` 进行比较也能返回 `true` ，因为对象的引用都指向常量池中的数值。

## 变量 常量

变量是指一个抽象的储存地址，其中存储某些信息，变量名则是引用数据用的地址别名。

常量是不可变的变量，使用 `final` 关键字修饰一个变量即为声明常量，常量在声明时就必须赋值，赋值后不可更改，命名规则：**字母全大写 单词以下划线隔开**。

Java 是强类型语言，变量在定义时必须指定其数据类型（基本数据类型、包装类、对象类型）。

JDK10 开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型，可以使用关键字 `var` 而无须指定类型。

变量命名规则：以字母、数字、下划线、美元符号组成，不能以数字开头，不能与关键字同名，大小写敏感，长度基本没有限制。

规范问题：

- 声明变量后，必须对变量赋值将其显式初始化，**不建议使用未初始化的变量。**
- 在 Java 中，变量的声明可以放在任何地方，但要尽可能靠近首次使用的地方，保持良好的编码风格。

## 运算符

运算符用于连接值，Java提供了一组丰富的算数和逻辑运算符以及数学函数。使用括号可以控制运算符优先级，括号中的运算最优先。不使用括号时就按照运算符优先级次序进行计算。

### 算数运算

| 运算符 | 意义                             |
| ------ | -------------------------------- |
| +      | 加法                             |
| -      | 减法                             |
| *      | 乘法                             |
| /      | 除法                             |
| %      | 取模，左操作数除以右操作数的余数 |

特殊规则：

- 当0作为被除数时，除数如果为整数将会产生一个异常，除数为浮点数时将会得到无穷大或NaN结果。
- 结合赋值方式：`x += 4;`等价于`x = x + 4;`

### 关系运算

| 运算符 | 意义       |
| ------ | ---------- |
| ==     | 检测相等性 |
| !=     | 检测不相等 |
| >      | 大于       |
| <      | 小于       |
| >=     | 大于等于   |
| <=     | 小于等于   |

特殊规则：

- 关系运算符全部返回boolean类型。
- 在Java中比较对象类型的内容要使用`equals()`方法，如与常量比较时，使用常量来调用方法避免NPE。

### 逻辑运算

| 运算符 | 意义                                 |
| ------ | ------------------------------------ |
| &&     | 逻辑与，当两个参数都为真，条件为真。 |
| \|\|   | 逻辑或，当任一参数为真，条件为真。   |
| ！     | 逻辑非，反转参数的逻辑状态。         |

特殊规则：

- 逻辑运算参数全都为boolean类型，返回也都为boolean类型。

- `&&`和`||`运算按照短路方式求值：如果第一个操作数已经能够确定表达式的值，则不计算第二个操作数，可以避免NPE。

### 位运算

| 运算符 | 意义                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 与。如果相对应位都是1，则结果为1，否则为0                    |
| \|     | 或。如果相对应位都是 0，则结果为 0，否则为1                  |
| ^      | 异或。如果相对应位值相同，则结果为0，否则为1                 |
| ~      | 取反。翻转操作数的每一位，即0变成1，1变成0                   |
| <<     | 左移。二进制各位全部左移若干位，高位丢弃，低位补0            |
| >>     | 右移。二进制各位全部右移若干位，高位补0                      |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以0填充。 |

特殊规则：

- 不存在`<<<`运算符。
- 计算机中进行`+-*/`运算都是转换为二进制运算，合理的运用位运算可以加快程序运行速度。
- 对一个数使用`<<1`，相当于操作数 `*2`。
- 对一个数使用`>>1`，相当于操作数`/2`。
- 对一个数进行`~`运算，再进行`&`运算，可以找到二进制数中最右的数值为1的位置。

### 自增自减

| 运算符 | 意义             |
| ------ | ---------------- |
| ++     | 自增，操作数加一 |
| --     | 自减，操作数减一 |

特殊规则：

- 只能用于变量，不能用于常量。
- 运算符实际有两种形式：前缀形式`++n`、后缀形式`n++`。都会使变量加一或减一，但用在表达式中时，前缀形式会先完成加1，而后缀形式会使用变量原先的值。
- **建议不要在表达式中使用自增自减运算符，这样的代码容易造成困惑，带来bug。**

### 三元运算符

| 运算符                    | 意义                                                         |
| ------------------------- | ------------------------------------------------------------ |
| boolean ? value1 : value2 | ?前应为一个boolean表达式，为true时返回:前的值，否则返回其后的值。 |

## 流程控制

程序运行有三种流程结构：顺序（默认，从上往下执行）、选择、循环。

### 选择结构

选择结构指在满足（或不满足）某个条件时，执行（或不执行）某段代码。

#### if else

```java
boolean flag = true; 

if (flag) {
    // 如果flag为真则执行此块
} else if (1 == 2) {
    // 当以上条件不满足时且当前表达式为真时执行此块
} else {
    // 当以上条件都不满足时执行此块
}
```

- if 可以单独使用，也可以搭配 else if 和 else 使用。
- else if 必须跟在 if 后，且可有多个else if.
- else 必须跟在 if 或 else if 后，只能有一个。

#### switch case

```java
int age = 18;

switch (age) {
	case 16 :
        // 当age为16时执行此块
    	// 如果不使用break或continue 则会继续执行下去
    case 17 :
        // 当age为17时执行此块
        // 如果不使用break或continue 则会继续执行下去
    case 18 :
        // 当age为17时执行此块
    default :
        // 当没有被break或没有满足任何条件时 到达判断时默认会执行此块
}
```

- 每个 case 中不要忘记使用 `break`，否则会继续往下执行，最终可能进入多个 case 块或 default 块。
- default 块是可选的，而编码规范要求必须有。

### 循环结构

循环结构指满足条件时，反复执行某段代码的行为。

#### for

```java
for(int i = 0; i < 9; i++){
    // 在满足布尔表达式时执行此块
}
```

-  `for` 三段表达式作用分别是：【初始化变量】; 【布尔表达式】; 【更新变量】。
-  在已知循环次数时使用。

#### while

```java
boolean flag = true;

// 方式1
while(flag){
    // 当布尔表达式为真时执行此块
}

// 方式2
do {
    // 循环块,先执行一次再执行判断
} while(flag);
```

- 常用在不能明确循环次数时。
- `do` 关键字后必须跟 `while` ，作用是使循环至少执行一次。
- 常需要在循环中转换布尔表达式的值，使跳出循环。

#### 迭代器

迭代器（Iterator）是集合接口的对象，可以用于实现循环结构，并在循环集合的同时删除元素，常规循环结构中删除元素将造成NPE.

```java
String[] arr = new String[] {"a", "b", "c", "d"};
List<String> list = Arrays.stream(arr).collect(Collectors.toList());
// 获取集合的迭代器
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
    // 删除元素
    it.remove();
}
// 此时list已经为空
list.forEach(System.out::println);
```

#### 增强for

```java
// 增强for，迭代器的语法糖
String[] arr = new String[] {"a", "b", "c", "d"};
for (String cur : arr) {
    // 遍历数组每个元素执行此块
}

// 集合中的forEach方法
List<String> list = Arrays.stream(arr).collect(Collectors.toList());
list.forEach(System.out::println);
```

### break continue

break：跳出当前循环块或 switch 块。

continue：结束当次循环，继续下一轮循环。

## 类与对象

类是一个模板，它描述一类对象的行为和状态。

对象是类的一个实例，有状态和行为。

在 Java 中定义一个类：

```java
// 定义一个公共类 dog ， 
public class Dog {
    
    // 创建一个对象实例
    SmallDog smallDog = new SmallDog();
    // 通过实例调用方法
    smallDog.eat();
    
    // 定义一个内部类
    private final class SmallDog{
        // 声明一个方法
        pubilc void eat(){}
    }
}
```

- 一个 `.java` 文件中只能有一个公共类，且必须与文件名相同。
- 类可以被 `static` 修饰，但 static 只能修饰内部类。被 static 修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。
- 类可以被 `final` 修饰，表示类为最终的，不可被继承。

## 方法

方法是程序语句的集合，在 C++ 中称为函数。它是解决一类问题的代码块，定义在对象中。

### 构造方法

每个类都有的方法，用于创建当前对象的实例。在不显式声明时，默认隐式拥有一个无参构造方法。 构造方法没有返回值，且方法名必须和类名一致。**每个实例的创建都要经过构造方法，可能利用这个特性初始化数据。**

### 访问修饰符

访问修饰符用于修饰方法、类、全局变量，通常在语句最前端。

Java 中包括 4 种访问修饰符（范围从大到小）：

- public：可在任何地方被调用。
- protected：可在本包及子类中被调用。
- default：可在本包中被调用。
- private：仅可在本类中被调用。

### 定义

方法定义在类中，包含方法头和方法体。

```java
// 方法头：
// public 访问修饰符
// String 返回值类型
// getHelloWorld 方法名
// (String name) 形式参数据类型 参数名
// throws RuntimeException 声明方法可能抛出的异常
public String getHelloWorld(String name) throws RuntimeException {
    // 方法体, 具体的执行语句
    String str = "Hello World for " + name;
    // 返回数据
    return str;
}
```

### 调用

在本类中使用 `this.方法名()` 调用，`this.` 可以省略。

在子类中使用 `super.方法名()` 调用。

静态方法中不能调用非静态方法，因为静态区会优先加载，此时非静态方法还未加载。 静态方法可以直接通过对象调用，不需要创建一个对象的实例。

方法为非静态方法时，在其他对象中需要创建方法的对象的实例，在满足访问范围的条件下，通过实例调用方法。

### 重写

方法重写是指子类继承父类后，对其方法进行重写，是实现多态的一种方式。

重写规则：

1. 方法名、形式参数[^1]列表必须相同。
2. 返回类型可以不相同，但是必须是父类返回值的派生类（ java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
3. 修饰符范围可以扩大但不能缩小。
4. 抛出的异常范围可以缩小但不能扩大。
5. 重写的方法使用 `@Override` 注解标记。
6. 声明为 final 的方法不能被重写。
7. 声明为 static 的方法不能被重写，但是能够被再次声明。
8. 重写方法的范围受到访问修饰符的控制，子类要能访问到父类的方法。

### 重载

方法重载是指在一个类中，函数名称相同，但形参不同的函数。是实现多态的一种方式。 当方法名称相同时，编译器会根据调用方法的参数个数、类型等逐个匹配，选择对应的方法，匹配失败编译器会报错。

重载规则：

1. 方法名称相同。
2. 形参列表不同（个数不同，数据类型不同，顺序不同）。
3. 返回值可以相同或不同（如果仅返回值不同，无法实现方法重载）。

### 可变参数

有时不能确认传递给方法的实际参数[^2]个数，那么就可以用到可变参数。从 JDK1.5 开始，Java 支持传递同类型的可变参数给一个方法。

使用规则：

1. 在方法声明中，在指定参数类型后加一个省略号 `...`
2. 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数，任何普通的参数必须在它之前声明。
3. 可变参数在方法中是一个数组类型。

```java
/**
 * 打印最大的数
 * */
public static void printMax(Double... numbers) {
    if (numbers.length == 0) {
        System.out.println("No argument passed");
        return;
    }
    double result = numbers[0];
    for (int i = 1; i < numbers.length; i++) {
        result = result > numbers[i] ? result : numbers[i];
    }
    System.out.println("Max number is " + result);
}


public static void main(String[] args) {
    printMax(2.0, 3.9, 1.1, 0.99);
}
```

### 递归

递归是指方法在方法体中调用自己的行为。通过递归可以找到局部最优解，可以用简单的方法解决一些复杂的问题。

需要注意方法的调用是一种压栈的过程，**当不确认方法的调用次数是否可控时，不建议使用递归，可能导致栈溢出。**

```java
public static void main(String[] args) {
    System.out.println(getFactorial(5));
}

public static long getFactorial(int number) {
    if (number == 1) {
        return 1;
    }
    return number * getFactorial(number - 1);
}
```

## 枚举

枚举是一个特殊的类，一般表示一组常量，当可以列出某些有穷序列集的所有成员时，可以定义枚举类标记。

使用关键字 `enum` 替代 `class` 定义一个枚举类，其中每个枚举值都是 `public static final` 的。

所有的枚举都继承自 `java.lang.Enum` 类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。  

使用中常通过属性和构造方法为枚举值设置属性，并提供 `get` 方法。

```java
public enum ColorEnum {
    RED("red", "红色"),
    BLUE("blue", "蓝色"),
    GREEN("green", "绿色"),
    ;
    // 成员变量
    private String code;
    private String desc;
    
    // get/set方法
    public String getCode() {return code;}
    public void setCode(String code) {this.code = code;}
    public String getDesc() {return desc;}
    public void setDesc(String desc) {this.desc = desc;}
    
    // 普通方法
    public static String getDesc(String code) {
        if (Objects.isNull(code) || code.isEmpty()) {
            return null;
        }
        for (ColorEnum ele : ColorEnum.values()) {
            if (ele.code.equals(code)) {
                return ele.getDesc();
            }
        }
        return null;
    }

    // 构造方法
    ColorEnum(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }
}
```

## 内部类

Java允许在一个类中再定义一个类，称为内部类，外部类只能有一个`public class`.

内部类包括：成员内部类、静态内部类、局部内部类、匿名内部类。

### 成员内部类

成员内部类作为外部类的一个成员，拥有`private`、`public`等访问修饰符，也可以用static来修饰。成员内部类加`static`变成**静态内部类**。

成员内部类是依附外部类而存在的，所以要创建成员内部类的对象，前提是必须存在一个外部类的对象。

成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。当出现和外部类同名的成员变量或者方法时，默认情况下访问的是成员内部类的成员。要访问外部类的同名成员，需要以下面的形式进行访问：

`外部类.this.成员变量`

`外部类.this.成员方法`

外部类也可以访问内部类的所有成员变量和方法（包括private），但必须先创建一个成员内部类的对象，再通过这个对象的引用来访问。

因为非静态成员内部类要依赖外部类，**所以成员内部类中不能存在任何`static`的变量和方法**，不能有static变量（除非是使用 `final static`同时修饰且属性字段是基本类型或者`String`类型的，那么是可以编译通过的，因为对于`final static`的变量是存放在常量池中的，不涉及到类的加载）

应用场景：

1. 使用成员内部类来定义复杂结构的api接口响应数据，实现序列化。
2. 使用成员内部类变相的实现类的多继承。
3. 实现单例模式。

```java
public class OutClass {
 	private double r = 0.0;
 	public static int s = 1;
    
    public InnerClass getInner() {
        return new InnerClass();
    }
 	
 	// 成员内部类
  	public class InnerClass {
    	public void drawSahpe() {
           	// 无条件访问外部类的private成员
      		System.out.println(r);
            // 无条件访问外部类的静态成员
      		System.out.prinlt(s);
    	}
  	}
    
    public static void main(String... str) {
        OutClass out = new OutClass();
 		// 创建内部类的两种方式
        InnerClass inner1 = out.getInner();
        InnerClass inner2 = out.new InnerClass();
    }
}
```

### 静态内部类

静态内部类是静态的成员内部类。`static` 修饰的类一定是内部类，静态内部类与非静态内部类之间最大的区别是非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类的对象，但是静态内部类没有。没有这个引用就意味着：

- 不需要依赖于外围类的对象就可创建。
- 不能使用外围类的非 `static` 成员变量和方法。（因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象）
- 允许有 `static` 属性、方法。

### 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。类似局部变量，不能有访问修饰符以及 `static` 修饰符。

```java
public void Test() {
    
    class InnerClass {
        private String name;
        // 存储至常量池，不影响类的加载
        final static String test = "1";
        
        public InnerClass(String name) {
            super();
            this.name = name;
        }
        
        public void say(String str) {
            System.out.println(name+":"+str);
        }
    }
    new InnerClass("world").say("hello");
}
```

### 匿名内部类

匿名内部类是唯一一种没有构造器的类（因为名字编译完成后才能确定，不能自定义构造器）。大部分匿名内部类用于接口回调。在编译时由系统自动起名为`Outter$[内部类名].class`，一般用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

Lambda表达式可以很方便返回一个匿名内部类，但并不是匿名内部类的语法糖，而是基于 `invokedynamic` 指令，在运行时使用ASM生成类文件来实现。

```java
public class Test {
    
    private Runnable runnable = new Runnable() {
        // 匿名内部类
        @override
        public void run() {}
    }
}
```

### 内部类常见问题

**外部类变量是怎么传递给内部类的？**

对于变量的类型分三种情况。

1. 非 `final` 局部变量，是通过构造器的方式传递进来的。
2. `final` 局部变量，因为变量是 `final` 的，所以在编译期间是确定的，编译器聪明的将表达式直接优化为常量数值。但如果常量赋值是运行时才能确定的，那么编译器意识到编译时值不能确定，所以还是采用构造器传参的形式实现。
3. 外部类成员变量，通过外部类的引用操作变量，但变量为 `private` 时，则会生成 `get/set方法`。

---

**匿名内部类使用外部类方法中的局部变量为何需要是final类型的？**

匿名内部类对象使用外部类方法中的非 `final` 修饰的局部变量，如果在内部类中没有修改的局部变量的值，编译运行没问题，这是因为编译器很智能，由于没有修改值，所以编译器认为这是 effectively final.

不是一定需要局部变量是 `final` 的，由于匿名内部类传递变量的实现是基于构造器传参，但是不能在匿名内部类中修改外部局部变量，**如果允许在匿名内部类中修改值，修改的是匿名内部类中的外部局部变量副本**，最终并不会对外部类产生效果，这样可能引起困扰，原以为修改会生效，事实上却并不会，所以就禁止在匿名内部类中修改外部局部变量。

## 包管理

Java 包机制，用于区别类名的命名空间。如果要在某个类中使用其他类成员，需要在当前类中导入那个类。

`package [url]`：声明类的位置。

`import [url]`：：导入包或对象。

## 值传递 引用传递

值传递（pass by value）：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

引用传递（pass by reference）：在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

在 Java 中参数传递方式是 **值传递，但是对于对象参数，值的内容是对象的引用，即等同于引用传递。**

## 编码规范

Java中编码命名规范有：

1. 所有变量、方法、类名：见名知意。
2. 类成员变量：首字母小写和驼峰原则：lastName.
3. 局部变量：首字母小写和驼峰原则。
4. 常量：大写字母和下划线：MAX_VALUE.
5. 类名：首字母大写和驼峰原则：Man，GoodMan.
6. 方法名：首字母小写和驼峰原则：run()，runRun().
7. 一般利用公司域名倒置作为包名。
8. 设置方法时，保持方法的原子性，即一个方法只完成一个功能，利于后期的扩展。

## 脚注

[^1]: 方法被调用时用于接收外界输入的数据，简称形参。
[^2]: 调用方法时实际传给方法的数据，简称实参。
